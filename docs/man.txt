Информация по атрибуту state у команд:
1 - присваивается новой команде(записан в структуру t_command)
3 - после команды идет пайп
7 - вроде как не нужен
8 - после команды идет следующая команда
========================================================

==============Информация по системным вызовам=====
#include <unistd.h>
int pipe (int filedes[2])

Функция pipe создает канал и помещает дескрипторы файла для чтения и записи (соответственно) в filedes [0] и filedes [1].


#include <unistd.h>

Создает дубликат файлового дескриптора oldfd.
int dup(int oldfd);
dup использует самый маленький свободный номер дескриптора.

int dup2(int oldfd, int newfd);
dup2 делает newfd копией oldfd, закрывая newfd если требуется.
--------------------------------

waitpid(pid_t pid, int *status, int options)
Приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс,
указанный в параметре pid, не завершит выполнение, или пока не появится сигнал, который либо завершает текущий процесс либо требует вызвать функцию обработчик.

Константа WUNTRACED означает возврат управления и для остановленных, но не отслеживаемых дочерних процессов, о статусе которых еще не было сообщено.
Статус для отслеживаемых остановленных подпроцессов также обеспечивается без этой опции.

Если status не равен NULL, то функции wait и waitpid сохраняют информацию о статусе в переменной, на которую указывает status.
Этот статус можно проверить с помощью макросов:
WIFEXITED(status) -не равно нулю если дочерний процесс успешно завершился
WEXITSTATUS(status) - возвращает восемь младших битов значения, которое вернул завершившийся дочерний процесс. Эти биты могли быть установлены в аргументе функции exit() или в аргументе оператора return() функции main().
Этот макрос можно использовать только если WIFEXITED вернул ненулевое значение.
==================================================


===========Добавить обработку специальной переменной $?==============
$? should work like in bash

$? - специальная переменная, которая содержит код возврата последней запущенной команды.
0 - успешное выполнение, все остальное код ошибки.
Holds the status of the last pipe close, back-quote string, or system() function.

Примерный алгоритм работы:
Последняя команда записывает в специальную переменную свой код возврата.
Любая команда которая обращает в шелле к переменной $? должна прочитать значение специальной переменной.
===================================================

Сигналы
==============
ctrl-C
Клавиатурный сигнал SIGINT - 2 - штатное завершение программы

ctrl-D
Зарегистрировать EOF

Ctrl-\
Клавиатурный сигнал SIGQUIT - 3 - завершение с выдачей отладочной информации
==============

Текущие вопросы:==============
1. Надо ли как то сохранять код возврата команд не из сабжекта, т.е. тех которые нам реализовывать не надо?
execve не возвращает управление, получается что непонятно как сохранить код возврата от того, что будет вызвано через execve (done)

2. Оригинальная pwd не меняет $? если папка, в которой выполняется команда, удалена. Надо ли копировать такое поведение?

3. Обсудить как должна работать команда export. Не выдает ошибку при попытке добавления ключа который начинается с цифры

4. В bash запустить which ls | ./minishell

5. Ломается cat, если сначала ввести cat, а потом несколько раз нажать Ctrl-D, а потом Enter

6.  в cat не работает Ctrl+D

==============================================
Кейсы для проверки:
1. dd а потом нажать Ctrl+D - вывод должен быть по формату аналогичен башу



==============================================
Текущий прогресс
1. Корректно делать SIGQUIT в дочернем процессе, который запускается через execve (done)
2. Корректно обрабатывать нажатие CTRL-D которое посылает EOF в read
===================================================================================
